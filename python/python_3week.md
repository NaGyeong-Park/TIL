# 데이터 구조 2022-01-24

## 순서가 있는 데이터 구조

__*메소드? 함수? : 함수>메소드 : 객체(class) 안에있는 함수 = 메소드__

### 문자열구조

- s.find(d) : x 첫번째 위치 반환, 없으면 -1 반환
- s.index () :  x 첫번째 위치 반환, 없으면 오류
- s.isalpha() : 알파벳 문자 여부(단순 알파벳 아닌 유니코드 상 Letter(한국어 포함))
- s.isupper() : 대문자 여부
- s.islower() :  소문자 여부
- s.istitle : 타이틀 형식 여부(단어간에 공백 시 앞 글자가 대문자)

### 문자열 변경 메소드

- 아니 immutable인데 가능? : 변경된 문자열로 된다

- s. replace(old, new[,count]) : 바꿀 대상 글자들 새로운 글자로 바꿔서 반환

- s.strip([chars]) : 공백이나 특정 문자 제거 (lstrip : 왼쪽 / rstrip : 오른쪽)

- s.split(sep = None, maxplit = -1 ): 공백이나 특정 문자 기준 분리 : 문자열 특정한 단위로 나눠 __리스트__로 반환

- 'separator'.join([iterable]) : 구분자로 iterable을 합쳐 문자열로 반환  __join은 string 메서드__

  - iterable에 문자열이 아닌 것을 집어넣으면 Type error

  - ex) `' '.join(['3', '5'])` => `'3 5'`

- s. capitalize() : '나 공백 이후를 대문자로 
- s.upper() :모두 대문자로  / s.lower() : 모두 소문자로 / s.swapcase() : 대 <-> 소



### 리스트

- 순서를 가지는 0개 이상의 객체 참조하는 자료형
- 

### 리스트 메소드

- ___L.append(x)___
- ___L.insert(i, x)___ : 리스트 인덱스 i에 x 삽입
- L.remove(x) : 리스트 가장 왼쪽에 있는 항목(첫 번째) x를 제거, 항목 존재하지 않으면 ValueError
- L.pop() : 리스트 가장 오른쪽에 있는 항목(마지막) 반환 후 제거
- L.pop(i) : 인덱스 i 항목 반환 후 제거
- ___L.extend(m)___ : 순회형 m의 모든 항목들의 리스트 끝에 추가(+=와 같음) _두 리스트를 합치는 너낌_
- L.index(x, start, end) : 리스트 있는 항목 중 가장 왼쪽 있는 항목 x의 인덱스 반환
- L.reverse() : 거꾸로 정렬
- L.sort(...) : 리스트 정렬 (매개변수 이용가능)
  - sorted와 구분!! : __sort는 원본 변경 / sorted는 원본변경X 정렬된 리스트 반환__
  - key도 있다. lamda나 함수 정의해서 key로 사용가능
  
- L.count(x) : x 몇 개 존재하는지 갯수 반환
- L.clear() : 모든 항목 삭제

 ### 튜플

- 변경 불가능(immutable)
- 튜플 관련 메소드 : 값에 영향 미치지 않는 메소드만 지원
- 리스트 메소드 중 항목을 변경하는 메소드들 제외하고 대부분 동일



## 순서가 없는 데이터 구조

### 셋(set)

- 순서 X,  mutable

### 셋 메소드

- s.add(x) : 항목에 x가 없으면 x추가
- s.pop() : 셋에서 랜덤하게 항목을 반환하고, 해당 항목 제거 /  set 비어있으면 KeyError
- s.remove(x)  : x를 s에서 삭제 / 존재하지않으면 KeyError
  - s.discard(elem) : 셋에서 삭제하고, 없어도 에러 안남!

- s.update : 여러 값 추가

### 딕셔너리

- 순서 없다, 키는 해시가능한 불변 자료형만 가능, 키의 값은 어떠한 형태든 관계 없다
- keys, values, items, get
- pop : 리스트(마지막or인덱스), 셋(랜덤), 딕셔너리(key)
- .update() : 값을 제공하는 key, value로 덮어씀 
  - ex) `{'apple' : '사'} /  .update(apple='사과')` => `'apple' : '사과'`



## 얕은 복사와 깊은 복사

- 얕은 복사 : 대입연산자 (=) 
  - 리스트 복사 확인하기 (예제 확인) => __대입연산자를 통한 복사는 해당 객체에 대한 객체 참조를 복사__
  - 해당 주소의 일부 값 변경시 참조하는 모든 변수에 영향
- 깊은 복사 : slice 이용해 같은 원소 가진 리스트지만 연산된 결과를 복사(다른주소)



# 에러/예외 처리

## 디버깅

### 문법 에러(Syntax Error)

- 파일이름, 줄번호, ^를 통해 파이썬이 문자를 읽어나갈 때 문제가 발생된 위치를 표현

### 예외

- 실행 중에 감지되는 에러들
- 예외는 여러 타입으로 나타나고, 타입이 메세지의 일부로 출력됨
  -  NameError, TypeError 등은 발생한 예외 타입의 종류
- 사용자 정의 예외 만들어 관리 가능

## 예외처리

## 예외 발생시키기

![image-20220125153657088](python_3week.assets/image-20220125153657088.png)

- except : 예외 발생하지않으면
- finally : 언제나 



# 객제지향 프로그래밍 (2022.01.26)

## 객체

- 객체 : 속성(value, attribute)+동작, 기능(Method)
- 객체(object, 개념)는 특정 타입의 __인스턴스(instance)__이다.
  - 인스턴스 : 클래스로 만들어진 객체(객체가 실제로 만들어짐)

- ___주니어 개발자 뽑을 때 클래스(설계도)와 인스턴스(만들어진것)의 차이가 뭔가요? : 단골___
- 타입 = 어떤 클래스로 만들어졌냐~? 데이터의 타입이 클래스 : 어떤 연산자와 조작이 가능한가?
  - 클래스를 만드는 것 : 새로운 데이터의 타입을 만드는 것
- 속성(attribute) : 어떤 상태(데이터)를 가지는가?
- 조작법(method) : 어떤 행위(함수)를 할 수 있는가?

## 객체지향프로그래밍이란?

- 왜 ? : 그 전에 _절차지향_ : 뭐가 불편해? : 절차를 중심으로 쭉~실행 : 느린 실행속도, 높은 난이도, 모든 객체의 역할과 기능을 이해해야 하기 때문에 프로그래밍 시간 다소요 :속성과 기능이 떨어져있어서 유지보수가 힘들었다
- 객체지향프로그래밍 : 속성과 기능이 합쳐진 객체는 유지보수가 편함
- 클래스 이름은 _파스칼_케이스로 쓰는게 좋다
- dir() : 객체의 속성과 메소드를 보여준다
  - . 하나 조차도...dot 연산자
  - 파이썬 내부적으로는 int랑 bool이랑 거의 같다

- 리터럴 : 객체의 클래스를 호출하지않고 그냥 객체를 만들어준다.
- __클래스 변수와 인스턴스 변수의 차이점__ : 모든 인스턴스 변수가 클래스변수를 공유하고있다. : 인스턴스 변수는 각각 가지고 있음
- '_ _init_ _'
- 같은 이름으로 된 함수를 두개 만들면 마지막의 함수가 적용된다
- is : 메모리 주소 비교하는 연산자
- __클래스간 비교는 우리가 구현해줘야한다...! _ _ eq_ _ __

```python
class Person:
    cnt = 0 # 클래스 변수
    
    def __init__(self): # 생성자, 클래스가 생성될 때 무조건 불리는 함수!
        self.name = name # 인스턴스 변수
        Person.cnt += 1
        
        
person_1 = Person('July')
print(person_1.cnt) # cnt = 0
July.cnt = 3 # July안에 새로운 인스턴스 변수를 만들어버렸다...! !주의!
```

