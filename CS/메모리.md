# 메모리 주소


## 16진수  : Hexadecimal

CS에서는 숫자를 16진수로 표현하는 경우가 많다. 16진수는 10진수보다 2진수를 간단하게 나타낼 수 있다.



## 10진수 -> 16진수

jpg 파일은 항상 255 216 255로 시작되고, 이것은 10진수이다. 하지만 실제 컴퓨터 내에서는 10진수를 사용하지 않는다. 컴퓨터는 0과 1만을 이해할 수 있기 때문이다.

![img](https://cphinf.pstatic.net/mooc/20170807_218/1502072784893AgAug_PNG/5.4_-01.png?type=w760)

2진수를 16진수로 바꿀때는 4bits씩 두 덩어리로 바꾸면 0000~1111까지는 16진수로 표기가 가능하다.

그럼 16진수에서 10부터 15까지는 어떻게 표기해야 할까? 10는 a, 11은 b ... 15는 f를 대입해 사용한다. 4 bits씩 16진수로 변환 후 __0x__를 붙여 16진수임을 알려준다.



## 16진수의 유용성

ASCII 코드를 살펴보자

![img](https://cphinf.pstatic.net/mooc/20170807_161/1502072871106NqRxw_PNG/5.4_-02.png?type=w760)

컴퓨터로 01000001 , ... 을 처리하기엔 길이가 너무 길다. 하지만 16진수로 표현하면 2진수로 표현했을 때 보다 훨씬 간단해진다. 또한 컴퓨터는 8개의 비트가 모인 바이트 단위로 정보를 표현한다. 2개의 16진수는 1바이트의 2진수로 변환되기 때문에 정보를 표현하기 매우 유용하다.



## 메모리 주소

![img](https://cs50.harvard.edu/x/2020/notes/4/n.png)

`int n = 50`이라고 해보자. 이 n값인 50은 메모리 어딘가에 4byte만큼 자리를 차지하며 저장이 되있을 것이다.

C에서는 `&`을 사용하여 변수의 메모리상 주소를 알 수 있다. 이는 16진법으로 표현된 메모리의 주소를 나타낸다.

```c
#include <stdio.h>

int main(void)
{
    int n = 50;
    printf("%p\n", &n);
}
```

반대로 `*`을 사용하면 그 메모리 주소에 있는 실제 값을 얻을 수 있다.

```c
#include <stdio.h>

int main(void)
{
    int n = 50;
    printf("%i\n", *&n);
}
```





# 포인터

 

```c
#include <stdio.h>

int main(void)
{
   int n = 50;
   int *p = &n;
   printf("%p\n", p);
   printf("%i\n", *p);
}
```

`*`연산자를 이용해 포인터 역할을 하는 변수를 선언 할 수 있다.

`*p`라는 __포인터 변수__에 &n이라는 값, 즉 변수 __n의 주소__를 저장한다.

`int *p`에서 `*`는 이 변수가 포인터라는 의미이고, int는 이 포인터가 int 타입의 변수를 가리킨다라는 의미다.

![img](https://cs50.harvard.edu/x/2020/notes/4/p.png)

![img](https://cs50.harvard.edu/x/2020/notes/4/pointing.png)

포인터의 주소는 신경쓰지말고, 내가 변수 n이 어디에 저장해놨지?? 라고 궁금하면 포인터를 쓴다. 그럼 포인터가 변수가 저장된 곳을 지정해 줄 것이다.