# 01. 협력하는 객체들의 공동체

객체지향의 중요한 개념 3가지 : `역할` `책임` `협력`

**요청과 응답으로 이루어진 `협력`**

- 커피 주문 예시
  - 손님이 캐셔에게 커피를 달라고 `요청` → 캐셔가 바리스타에게 커피를 제조해달라고 `요청` → 바리스타가 커피를 만들었다고 캐셔에게 `응답` → 캐셔가 커피를 준다고 `응답`

⇒ `요청`과 `응답`을 통해서 다른 사람과 협업

**역할과 `책임`**

역할을 가지고 있다는 것은 책임을 가지고 있다는 것과 비슷하다.

- 손님 : 커피를 주문할 `책임`
- 캐셔 : 커피를 주문받을 `책임`, 바리스타가 만든 커피를 건내줄 `책임`
- 바리스타 : 커피를 제조할 `책임`

**특징**

- 여러 사람이 동일한 `역할`을 맡을 수 있다
- `역할`은 대체 가능성(substituable)을 의미한다
- `다형성` : 동일한 `책임`을 다른 방법으로 수행할 수 있다
- 한 사람이 동시에 여러 `역할`을 수행할 수 있다 : 바리스타 + 캐셔

⇒ 여기서 사람을 객체, 요청을 메세지, 요청을 처리하는 방법을 메서드로 바꾸면 객체지향

**객체지향 설계의 핵심, `책임`**

객체지향 설계의 품질을 결정하는 요소

책임이 불분명하다면 애플리케이션의 미래도 불분명

`역할` 은 유연하고 재사용 가능한 협력관계를 구축하는데 중요한 설계 요소

⇒ 대체 가능한 `역할`과 `책임`은 객체지향 패러다임의 중요한 기반을 제공하는 `다형성`과도 깊게 연관

**특징**

- 여러 객체가 동일한 역할 수행 가능
- 역할은 대체가능성을 지님
- 각 객체는 책임을 수행하는 방법을 자율적으로 선택 가능
- 하나의 객체가 동시에 여러 역할 수행 가능

**협력 속에 사는 객체**

객체지향 애플리케이션의 아름다움을 결정하는 것이 협력이라면 `협력`이 얼마나 조화를 이루는지 결정하는 것은 `객체` ⇒ 협력의 품질을 결정하는 것이 `객체`

협력 공동체의 일원으로서의 객체는 두가지 덕목을 가져야한다.

1. 충분히 협력적
   - 다른 객체의 요청을 충실히 귀 기울이고 다른 객체에게 적극적 도움을 요청할 정도로 마음을 열어야 함
   - 외부 도움을 무시하고 혼자 처리하려고 하는 전지전능 객체(god object)는 복잡도 때문에 자멸할 수 밖에 없음
2. 충분히 자율적
   - 요청에 어떤 방식으로 응답할지 객체 스스로 결정
   - 요청 할지말지도 객체 스스로 결정
   - 스스로 원칙에 따라 어떤 일을 하거나 자기 스스로 통제하여 절제

⇒ 공동의 목표를 위해 협력하지만 객체는 스스로 결정과 판단을 통해 행동하는 자율적인 존재

**상태와 행동을 함께 지닌 객체**

바리스타가 커피 제조법을 까먹지 않는 것처럼 객체도 본인의 상태를 알고 있어야 한다.

객체가 협력에 참여하기 위한 어떤 행동을 한다면 행동을 하는데 필요한 상태도 알고있어야 한다.

⇒ 객체는 상태와 행위를 하나의 단위로 묶는 자율적인 존재

객체의 자율성은 외부와 내부를 명확하게 구분하는 것으로부터 나온다

객체의 사적인 부분은 객체 스스로 관리, 객체 외부에서는 접근이 허락된 수단을 통해서만 객체와 의사소통 해야함

⇒ 객체는 다른 객체가 `무엇`을 수행하는 지는 알 수 있지만, `어떻게` 수행하는 지는 알 수 없다

과거 전통적이 개발 방법은 데이터와 프로세스를 엄격하게 구분

→ 객체지향에서는 데이터와 프로세스를 하나의 틀 안에 묶어놓아 객체의 자율성 보장

→ 자율적인 객체로 구성된 공동체는 재사용이 용이하고 유지보수가 좋음

**협력과 `메세지`**

객체지향에서는 서로 요청을 보내고 응답하기 위한 의사소통 수단으로 `메세지`를 사용한다

메세지를 전송하는(요청자) 객체를 송신자(sender)라고 하고, 메세지를 수신하는(응답자) 객체를 수신자(receiver)라고 한다.

**`메서드`의 자율성**

객체가 수신된 메세지를 처리하는 방법을 `메서드`(method)라고 한다

객체지향 프로그래밍 언어에서 메서드는 클래스 안에 포함된 함수나 프로시저를 통해 구현

→ 어떤 객체에게 메세지를 전송하면 결과적으로 메세지에 대응하는 특정 메서드를 실행

메시지를 수신한 객체가 실행 시간에 메서드를 선택할 수 있는 있음

- 다른 프로그래밍 언어와 객체지향 프로그래밍 언어를 구분짓는 특징
- 프로시저 호출에 대한 실행 코드를 컴파일 시간에 결정하는 절차지향과 구분되는 특징

⇒ 메세지와 메서드의 분리는 객체 협력에 참여하는 객체들의 자율성 증진 ex)핸드드립식, 머신식

외부 요청이 무엇인지 표현하는 메세지와 요청을 처리하기 위한 구체적인 방법인 메서드를 분리하는 것은 객체의 자율성을 높이는 핵심 메커니즘 ⇒ `캡슐화`(encapsulation)와 관련있다

## 객체지향의 본질

- 객체지향이란 **시스템을 상호작용하는 자율적인 객체들의 공동체**, 객체를 이용해 시스템을 분할
- 자율적인 객체란 `상태`와 `행위`를 함께 가지고 스스로 자기자신을 `책임`지는 객체
- 객체는 시스템의 **행위를 구현하기 위해서 다른 객체와 `협력`**, 각 객체는 협력 내에서 정해진 역할을 수행.     `역할`은 관련된 책임의 집합
- 객체는 다른 객체와 협력을 위해 `메세지`를 전송, 메세지를 수신한 객체는 메세지를 처리하는데 적합한 `메서드`를 **자율적으로 선택**



# 02. 이상한 나라의 객체

> 객체 : **식별가능한 개체 또는 사물**. 물건같이 만질 수 있는 사물일 수도 있고, 시간처럼 추상적인 개념일 수도 있다. 객체는 구별 가능한 `식별자`, 특징적인 `행동`, 변경 가능한 `상태`를 가진다. 소프트웨어 안에서 객체는 저장된 상태와 실행 가능한 코드를 통해 구현된다.

## **상태**

객체가 주변 환경과 상호작용에 어떻게 반응하는가는 그 시점까지 객체에게 어떤 일이 발생했느냐에 따라 좌우됨

과거에 발생한 행동의 이력을 통해 현재 발생한 행동의 결과를 판단하는 방식은 복잡하고 번거롭고 이해하기 어려움 ⇒ 행동의 과정과 결과를 단순하게 기술하기 위해서 `상태`라는 개념을 고안

ex) 비행기 탈 수 있나? 발권상태, 드라이브 갈 수 있나? 시동 상태, 자판기 돈 넣었나? 자판기 투입 금액 상태

`상태`를 이용하면 과거에 얽매이지 않고 현재를 기반으로 객체의 행동 방식 이해 가능

⇒ 상태는 근본적으로 세상의 복잡성 완화, 인지 과부하를 줄일 수 있는 중요한 개념

**상태와 프로퍼티**

단순한 값들은 객체가 아니다. 하지만 객체의 상태를 나타내기 위한 중요한 수단

모든 객체의 `상태`는 **단순한 값**과 **객체의 조합**으로 표현 가능

`프로퍼티` : 상태를 구성하는 모든 특징, `정적`(변경되지않고 고정됨) : 사람의 키, 몸무게, 위치, 음료수

`프로퍼티 값` : `동적`(시간의 흐름에 따라 변경) : 160cm, 음료수 양

**프로퍼티 = 링크 + 속성**

`링크`(link)

객체와 객체 사이의 의미있는 연결: 앨리스(객체)가 들고있는 음료(객체)

객체와 객체사이에 링크가 존재해야지 메세지 주고받을 수 있음

객체가 다른 객체를 참조할 수 있다는 것을 의미 ⇒ **한 객체가 다른 객체의 식별자를 알고있다**

`속성` (attribute)

객체를 구성하는 단순 값

> 상태 : 특정한 시점에 객체가 가지고 있는 정보의 집합. 객체의 구조적 특징 표현. 객체의 상태는 객체에 존재하는 정적인 프로퍼티와 동적인 프로퍼티 값으로 구성. 객체의 프로퍼티는 단순 값과 다른 객체를 참조하는 링크로 구분

## **행동**

**상태와 행동**

객체가 취하는 행동은 객체 자신의 상태를 변경시킨다 → 객체 행동에 의해 객체의 상태가 변경된다는 것은 행동이 `부수 효과`(side effect)를 초래했다는 것을 의미

상태-행동 사이 관계

- 객체의 행동은 상태에 영향을 받는다
- 객체의 행동은 상태를 변경시킨다

⇒ 상태라는 개념을 이용해 행동을 다음 두 가지 관점에서 서술할 수 있음

- 상호작용이 현재의 상태에 어떤 방식으로 **의존**하는가 : 앨리스의 키가 40cm이하라면 문을 통과 가능
- 상호작용이 어떻게 현재의 상태를 **변경**시키는가 : 문을 통과한 후 앨리스의 위치는 정원

**협력과 행동**

객체의 행동은 객체가 협력에 참여할 수 있는 유일한 방법이다

객체가 다른 객체와 메세지로만 으사소통이 가능하다. 객체는 수신된 메세지에 따라서 적절한 행동을 통해 협력에 참여하고, 그 결과로 자신의 상태를 변경한다.

협력에 참가하는 과정에서 자신의 상태뿐만 아니라 다른 객체의 상태 변경을 유발할 수도 있다. : 앨리스가 음료수를 마시면 음료의 양이 줄어듬

⇒ 객체의 행동은 이 두 가지 관점의 부수효과를 명확히 서술해야한다.

- 객체 자신의 변경
- 행동 내 협력하는 다른 객체에 대한 메세지 전송

> 행동 : 외부 요청 또는 수신된 메세지에 응답하기 위해 동작하고 반응하는 활동. 행동의 결과로 객체는 자신의 상태를 변경하거나 다른 객체에게 메세지 전달 가능. 객체는 행동을 통해 다른 객체와의 협력에 참여하므로 행동은 외부에 가시적이여야 함

**상태 캡슐화**

현실에선 앨리스가 음료의 상태를 변경하지만 객체지향의 세계에선 앨리스는 음료에 음료량을 줄이라는 메세지를 전달하지 음료의 상태를 바꾸진 못한다. 앨리스는 단지 음료의 양이 줄어들 것이라는 것을 믿고 메세지를 전달할 뿐

![image](https://user-images.githubusercontent.com/97649363/186671694-fa4cdf0d-5037-4485-976f-73d82913e22a.png)

앨리스에게 전달되는 메세지는 `drinkBeveage()`  beverage에게 전달되는 메세지는 `drunken(quantit)`

⇒ 메세지 송신자는 메세지 수신자의 상태 변경에 대해서는 알 길이 없다 : `캡슐화`

객체는 **상태를** 캡슐안에 감춰둔 채 **외부로 노출하지 않는다**. 외부로 노출하는 것은 행동뿐이고 외부에서 객체로 접근할 수 있는 유일한 방법 역시 행동 뿐이다.

⇒ 객체의 자율성을 높임

⇒ 상태를 잘 정의된 행동 집합 뒤로 캡슐화하는 것은 객체의 자율성을 높이고 협력을 단순하고 유연하게 만든다





## 식별자

객체는 식별 가능하다 = 객체를 서로 구별할 수 있는 특정 프로퍼티, 즉 `식별자`가 객체 안에 존재한다

단순한 값은 식별자를 가지지 않는다

객체는 값과 객체를 가지는데, 값과 객체의 가장 큰 차이점은 `객체`는 `식별자`를 가지지만 값은 가지지 않는다

값의 상태는 변하지 않는다 : `불변 상태`(immutable state) :  두 인스턴스의 상태가 같다면 두 인스턴스는 같다

⇒ `동등성`(equality) : 상태를 이용해 두 값이 같은지 판단할 수 있는 성질

객체는 시간에 따라 변경되는 상태를 포함한다, 행동을 통해 상태를 변경한다 : `가변 상태`(mutable state) :  타입이 같은 두 객체 상태가 같더라도 두 객체는 독립적인 별개의 객체로 다뤄져야한다. 그리고 두 객체의 상태가 다르더라도 식별자가 같으면 두 객체는 같은 객체로 판단 가능하다.

⇒ `동일성`(identical) : 식별자를 기반으로 객체가 같은지 판단할 수 있는 성질

→ 상태가 같더라도 객체의 동일성을 판단할 수 없는 이유는 시간의 흐름에 따라 객체의 상태가 변하기 때문

> 식별자 : 어떤 객체를 다른 객체로 구분하는 데 사용하는 객체의 프로퍼티. 값은 식별자를 가지지 않기 때문에 상태를 이용한 동등성 검사를 통해 두 인스턴스를 비교해야 함. 객체는 상태가 변경될 수 있기 때문에 식별자를 이용한 동일성 검사를 통해 두 인스턴스 비교 가능

`참고 객체`(reference object), `엔티티`(entity) : 식별자를 지닌 전통적인 의미의 객체

`값 객체`(value object) : 식별자를 가지지 않는 값

식별자는 객체지향 패러다임의 표현력을 높이는 데 중요한 역할을 한다. 객체지향의 세계는 상태가 변하지 않는 값과 상태가 변하는 객체들이 서로 균형을 맞추며 조화를 이루는 사회여야 한다.

**객체의 특징**

- 객체는 상태를 가지며 상태는 변경 가능하다
- 객체의 상태를 변경시키는 것은 행동이다
  - 행동의 결과는 상태에 의존적이며 상태를 이용해 서술 가능하다
  - 행동의 순서가 실행 결과에 영향을 미친다
- 객체는 어떤 상태에 있더라도 유일하게 식별 가능

## 기계로서의 객체

객체의 상태를 조회하는 작업을 `쿼리`(query)라고 하고 객체의 상태를 변경하는 작업을 `명령`(command)이라고 한다. 객체가 외부에 제공하는 행동의 대부분은 쿼리와 명령으로 구성된다.

객체를 블랙박스 기계에 비교해보자.

사각형 모양의 버튼을 누르면 객체의 상태를 변경할 수 있다

동그라미 버튼을 누르면 객체의 상태를 조회할 수 있다

⇒ 객체에 접근할 수 있는 유일한 방법은 객체가 제공하는 `행동` (버튼) 뿐이다 : `캡슐화` 강조

기계 내부를 열어 상태를 조회하지 않고, 동그라미 버튼을 눌러 상태를 조회한다 ⇒ 객체에서 메세지를 보내 상태를 조회하여 디스플레이에 출력

`식별자` : 같은 기계 2개, 하지만 두 기계를 구분된 별개의 객체라고 인식

`협력` : 앨리스 기계의 음료를 마시다 누르기 → 링크를 통해 음료 기계에게 마셔지다 라는 버튼 눌리게 전송

## 행동이 상태를 결정한다

초보자들은 객체지향 설계를 할 때 객체에 필요한 상태가 무엇인지 결정하고, 그 이후에 행동을 결정한다. 이는 설계에 나쁜 영향을 끼친다

1. 상태를 먼저 결정할 경우 캡슐화가 저해된다. 상태가 내부에 깔끔하게 캡슐화되지 못하고 공용 인터페이스에 그대로 노출 될 확률이 높다
2. 객체를 협력자가 아닌 고립된 섬으로 만든다. 상태를 먼저 고려하는 방식은 협력이란 문맥에서 벗어난 채 객체를 설계하게 함으로써 자연스럽게 협력에 적합하지 못한 객체를 창조하게 된다
3. 객체의 재사용성이 저하된다. 객체의 재사용성은 다양한 협력에 참여할 수 있는 능력에서 나온다. 상태에 초점을 맞춘 객체는 다양한 협력에 참여하기 어렵다

**⇒ 객체가 적합성을 결정하는 것은 객체의 상태가 아니고 객체의 행동이다**

협력 안에서 객체의 행동은 결국 객체가 협력에 참여하면서 완수해야 할 책임을 의미

⇒ 어떤 책임이 필요한가를 결정하는 과정이 전체 설계를 주도해야 한다.

⇒ `책임-주도 설계`(Responsibility-Driven Design)는 협력이라는 문맥 안에서 객체의 행동을 생각하게 하므로 응집도 높고 재사용 가능한 객체를 만들 수 있게 한다.
