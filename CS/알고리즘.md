#  검색 알고리즘

컴퓨터는 배열 안을 하나하나 살펴봐야한다. 배열의 정렬 여부에 따라서 원하는 값을 찾을 때는 이런 방법이 있다.

## 선형 검색 : Linear Search

```sudo
For i from 0 to n–1

    If i'th element is 50

        Return true

Return false
```

배열의 인덱스를 처음부터 끝까지 하나하나 방문하면서 그 값이 속하는지 검사한다.

## 이진 탐색 : Binary Search

```sudo
If no items

    Return false

If middle item is 50

    Return true

Else if 50 < middle item

    Search left half

Else if 50 > middle item

    Search right half
```

만약 배열이 정렬되어 있다면 배열 중간 인덱스부터 시작해 찾고자 하는 값과 비교하며 그보다 작은 인덱스 또는 큰 인덱스로 이동을 반복한다.



# 알고리즘 표기법

## Big O

![img](https://cs50.harvard.edu/x/2020/notes/3/running_time.png)

Big O 표기법으로 나타낸 알고리즘에 걸리는 시간이다. :  알고리즘 **실행 시간의 상한**

여기서 O는 "on the order of " 의 약자로 쉽게 생각하면 "~만큼의 정도로 커지는" 것이라고 볼 수 있다.

O(n)은 n만큼 커지는 것으로 n이 늘어날 수록 선형적으로 늘어난다. O(n/2)도 결국 n이 커지면 /2가 의미없어 O(n)으로 표기한다.

### Big O 표기

- O(n^2)
- O(n log n)
- O(n) - 선형 검색
- O(log n) - 이진 검색
- O(1)

## Big Ω

알고리즘 실행 시간의 하한

선형 검색에서는 한 번만에 검색을 끝낼 수도 있기에 Ω(1)이다.

### Big Ω 표기

- Ω(n^2)
- Ω(n log n)
- Ω(n) - 배열 안에 존재하는 값의 개수 세기
- Ω(log n)
- Ω(1) - 선형 검색, 이진 검색



# 선형검색

선형검색 : 원하는 원소가 발견될 때까지 처음부터 마지막 자료까지 차례대로 검색



## 효율성 그리고 비효율성

![image-20220625004444390](%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.assets/image-20220625004444390.png)

__선형 검색 알고리즘__은 정확하지만 아주 효율적이지 못한 방법.

```
리스트의 길이가 n이라고 했을 때, 최악의 경우 리스트의 모든 원소를 확인해야 하므로 n번만큼 실행됩니다.
여기서 최악의 상황은 찾고자 하는 자료가 맨 마지막에 있거나 리스트 안에 없는 경우를 말합니다.
만약 100만 개의 원소가 있는 리스트라고 가정해본다면 효율성이 매우 떨어짐을 느낄 수 있습니다.
반대로 최선의 상황은 처음 시도했을 때 찾고자 하는 값이 있는 경우입니다.
평균적으로 선형 검색이 최악의 상황에서 종료되는 것에 가깝다고 가정할 수 있습니다.
```

선형검색은 자료가 정렬되어 있지 않거나 그 어떤 정보도 없어 하나씩 찾아야 하는 경우에 유용하다.



```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // numbers 배열 정의 및 값 입력
    int numbers[] = {4, 8, 15, 16, 23, 42};

    // 값 50 검색
    for (int i = 0; i < 6; i++)
    {
        if (numbers[i] == 50)
        {
            printf("Found\n");
            return 0;
        }
    }
    printf("Not found\n");
    return 1;
}
```

주어진 배열에서 특정 값을 찾기 위해서 선형 검색을 사용한 코드이다.

배열의 크기만큼 for 루프를 돌면서 배열의 인덱스를 차례대로 방문하며 찾는 값이 있는지를 검사하면 된다.

여기서 return 0을 해주는건 성공, return 1은 실패이다. 왜 0과 1이냐면 관습적인 것이다...!





```c
#include <cs50.h>
#include <stdio.h>
#include <string.h>

typedef struct
{
    string name;
    string number;
}
person;

int main(void)
{
    person people[4];

    people[0].name = "EMMA";
    people[0].number = "617–555–0100";
    people[1].name = "RODRIGO";
    people[1].number = "617–555–0101";
    people[2].name = "BRIAN";
    people[2].number = "617–555–0102";
    people[3].name = "DAVID";
    people[3].number = "617–555–0103";

    // EMMA 검색
    for (int i = 0; i < 4; i++)
    {
        if (strcmp(people[i].name, "EMMA") == 0)
        {
            printf("Found %s\n", people[i].number);
            return 0;
        }
    }
    printf("Not found\n");
    return 1;
}
```

`typedef struct`로 person이라는 이름의 구조체를 자료형으로 정의하고 person 자료형의 배열을 선언

그 안의 속성값은 `.`으로 연결해 접근이 가능하다.



# 버블 정렬 : Bubble sort

정렬 알고리즘 중 하나는 버블 정렬이다.

버블 정렬은 두 개의 인접한 자료 값을 비교하면서 위치를 교환하는 방식으로 정렬하는 방법이다.

버블 정렬은 단 두개의 요소만 정렬해주는 좁은 범위의 정렬에 집중한다. 간단하지만 단 하나의 요소를 정렬하기 위해 너무 많이 교환하는 낭비가 발생할 수도 있다.



`6 3 8 5 2 7 4 1` 이 숫자들을 오름차 순으로 정렬해보겠다.

![image-20220625005712002](%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.assets/image-20220625005712002.png)

```
교환 전: **6 3** 8 5 2 7 4 1

교환 후: **3 6** 8 5 2 7 4 1

6과 8은 교환할 필요가 없으니 그대로 두겠다.

교환 전: 3 6 **8 5** 2 7 4 1

교환 후: 3 6 **5 8** 2 7 4 1

이렇게 진행하면 결국은 이렇게 된다.

3 6 5 2 7 4 1 8

음... 아직 멀었으니 더해보겠다

**3 6** 5 2 7 4 1 8

3 **6 5** 2 7 4 1 8 (교환)

3 5 **6 2** 7 4 1 8 (교환)

3 5 2 **6 7** 4 1 8 

3 5 2 6 **7 4** 1 8 (교환)

3 5 2 6 4 **7 1** 8 (교환)

3 5 2 6 4 1 **7 8**

...
1 2 3 4 5 6 7 8
```

이러한 방식을 버블 정렬이라고 한다. 마치 거품이(비교 및 교환이) 터지면서 위로 올라오는 (배열의 옆으로 이동하는) 방식이기 때문이다. 

```sudo
Repeat n–1 times

    For i from 0 to n–2

        If i'th and i+1'th elements out of order

            Swap them
```

중첩 루프를 돌아야 하고, n개 값이 주어졌을 때 n-1번, n-2번 반복되기에 (*n*−1)∗(*n*−2)=*n*2−3*n*+2 번의 비교 교환이 필요하다. 여기서 제일 큰 요소는 n^2이니까 버블 정렬 실행 시간의 상한은 __O(n^2)__이다.

정렬 되어있는 여부에 상관없이 루프를 도므로 실행시간의 하한도 여전히 **Ω(n^2)**이다.



# 선택 정렬

배열 안의 자료 중 가장 작은 수(혹은 큰 수)를 찾아 첫 번째 위치의 수(혹은 가장 마지막 위치의 수)와 교환 해주는 방식의 정렬이다.선택정렬은 __교환 횟수를 최소화__하는 반면, 각 자료를 비교하는 횟수는 증가한다.

![image-20220625010628632](%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.assets/image-20220625010628632.png)

```
다음과 같은 정렬되지 않은 숫자들을 오름차순 정렬해보도록 하겠습니다.
6 3 8 5 2 7 4 1
먼저 아래 숫자들 중에서 가장 작은 값을 찾습니다.
6 3 8 5 2 7 4 1
가장 작은 값인 1은 가장 앞에 있어야 하므로 현재 리스트의 첫 번째 값인 6과 교환합니다.
1 3 8 5 2 7 4 6
그리고 정렬되어 있는 1은 제외하고, 두 번째 숫자부터 시작해서 또 가장 작은 값을 찾습니다.
1 3 8 5 2 7 4 6
가장 작은 값인 2는 정렬되지 않는 숫자들 중에서 가장 앞에 있어야 하므로 3과 교환합니다.
1 2 8 5 3 7 4 6
이 과정을 더 이상 교환이 일어나지 않을때까지 반복하면, 아래와 같이 오름차순 정렬이 완료됩니다.
1 2 3 4 5 6 7 8
```

```sudo
For i from 0 to n–1

    Find smallest item between i'th item and last item

    Swap smallest item with i'th item
```

여기서도 두번 루프를 돌아야한다...ㅠㅠ 

n(n-1)(n-2)....1 = n(n+1)/2 = ... = __O(n^2)__

최악의 경우도 마찬가지로  **Ω** **(n^2)**이다.



## 버블정렬과 선택 정렬의 차이

선택정렬은 버블정렬과 다르게 몇 번 교환해주었는지 횟수를 셀 필요가 없다. 하지만 훨씬 더 많은 비교가 필요하기때문에 비용이 많이 든다. 

원래 배열의 순서와 상관없이 선택 정렬로 정렬되는 배열은 n-1번의 교환이 필요하다. 이는 버블 정렬 교환횟수보다는 적다. 

그러나 한번 교환이 일어나기 우해서 정렬되지 않은 모든 수와 비교해야 하므로 n^2번의 비교가 이루어진다.





# 정렬 알고리즘의 실행시간

**실행시간의 상한**

- O(n^2): 선택 정렬, 버블 정렬
- O(n log n)
- O(n): 선형 검색
- O(log n): 이진 검색
- O(1)



**실행시간의 하한**

- Ω(n^2): 선택 정렬, 버블 정렬
- Ω(n log n)
- Ω(n)
- Ω(log n)
- Ω(1): 선형 검색, 이진 검색



버블 소트... 더 잘 해볼 수 없을까...?

정렬이 모두 되어있는 숫자 리스트가 주어진다면

원래 sudo 코드는 이렇다

```sudo
Repeat n–1 times

    For i from 0 to n–2

        If i'th and i+1'th elements out of order

            Swap them
```

안쪽 루프에서 만약 교환이 하나도 일어나지 않는다면 이미 정렬이 잘 되어있을 것이다. 그래서 바깥쪽 루프를 교환이 일어나지 않을 때 까지만 수행하도록 바꿀 수 있다

```sudo
Repeat until no swaps

    For i from 0 to n–2

        If i'th and i+1'th elements out of order

            Swap them
```

최종적으로 버블 정렬의 하한은 **Ω(n)**이 된다.

**실행시간의 하한**

- Ω(n^2): 선택 정렬
- Ω(n log n)
- **Ω(n): 버블 정렬**
- Ω(log n)
- Ω(1): 선형 검색, 이진 검색



# 재귀 : Recursion

함수가 본인 스스로를 호출해서 사용할 수 있다. 이것이 __재귀__이다!

![image-20220625013128271](%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.assets/image-20220625013128271.png)

```
#

##

###

####
```

이 코드를 재귀적으로 그려볼까?

```c
#include <cs50.h>
#include <stdio.h>

void draw(int h);

int main(void)
{
    int height = get_int("Height: ");

    draw(height);
}

void draw(int h)
{
    // 높이가 0이라면 (그릴 필요가 없다면)
    if (h == 0)
    {
        return;
    }

    // 높이가 h-1인 피라미드 그리기
    draw(h - 1);

    // 피라미드에서 폭이 h인 한 층 그리기
    for (int i = 0; i < h; i++)
    {
        printf("#");
    }
    printf("\n");
}
```

## 주의점 : 스택

![image-20220625013157298](%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.assets/image-20220625013157298.png)

재귀 함수에서 동일한 함수를 계속해서 호출될 때마다 함수를 위한 메모리가 계속 할당된다. 함수가 호출될 때마다 사용되는 메모리를 __스택__이라고 한다. 컴퓨터가 일을 처리하는데 관리를 하는 역할인 운영체제는 함수를 실행할 수 있도록 일정량의 바이트를 주고, 그 공간에 함수의 변수나 다른 것들을 저장할 수 있도록 한다. 그래서 재귀 함수를 이용하다보면 함수가 종료되지않고, 함수가 계속해서 호출되는 경우가 있기도 하다. 이 경우 __스택 공간이 초과되고__ 프로그램 충돌이 발생한다. 그래서 과도하게 스택 메모리가 사용되지 않도록 유의해야 한다.

![image-20220625013419095](%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.assets/image-20220625013419095.png)

![image-20220625013440442](%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.assets/image-20220625013440442.png)

ㅋㅋㅋ WOW~~



# 병합 정렬 : Merge Sort

원소가 한 개가 될 때까지 계속해서 반으로 나누다가 다시 합쳐나가며 정렬을 하는 방식

![image-20220625014632743](%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.assets/image-20220625014632743.png)

```
마찬가지로 다음 숫자들을 오름차순으로 정렬해 보겠습니다.
7 4 5 2 6 3 8 1
먼저 숫자들을 반으로 나눕니다.
7 4 5 2 | 6 3 8 1
그리고 나눠진 부분 중 첫번째를 한번 더 반으로 나눠봅니다.
7 4 | 5 2 | 6 3 8 1
마지막으로 한 번 더 나눠봅니다.
7 | 4 | 5 2 | 6 3 8 1

이제 숫자가 두 개 밖에 남지 않았으므로 더 이상 나누지 않고, 두 숫자를 다시 병합합니다.
단, 이 때 작은 숫자가 먼저 오도록 합니다. 4와 7의 순서를 바꿔서 병합하는 것이죠.
4 7 | 5 2 | 6 3 8 1
마찬가지로 5 2 부분도 반으로 나눈 후에 작은 숫자가 먼저 오도록 다시 병합할 수 있습니다.
4 7 | 2 5 | 6 3 8 1

그럼 이제 4 7과 2 5 두 개의 부분들을 병합하겠습니다.
각 부분들의 숫자들을 앞에서 부터 순서대로 읽어들여 비교하여 더 작은 숫자를 병합되는 부분에 가져옵니다.
즉, 4와 2를 먼저 비교해서 2를 가져옵니다. 그 후에 4와 5를 비교해서 4를 가져옵니다.
그리고 7과 5를 비교해서 5를 가져오고, 남은 7을 가져옵니다.
2 4 5 7 | 6 3 8 1
이제 남은 오른쪽 4개의 숫자들도 위와 동일한 과정을 거칩니다. 
2 4 5 7 | 1 3 6 8
마지막으로 각각 정렬된 왼쪽 4개와 오른쪽 4개의 두 부분을 병합합니다.
2와 1을 비교하고, 1을 가져옵니다. 2와 3을 비교하고, 2를 가져옵니다. 4와 3을 비교하고, 3을 가져옵니다.
4와 6을 비교하고… 이 과정을 병합이 끝날때까지 진행하면 아래와 같이 정렬이 완료됩니다.
1 2 3 4 5 6 7 8
전체 과정을 요약해서 도식화해보면 아래와 같습니다.

7 | 4 | 5 | 2 | 6 | 3 | 8 | 1 → 가장 작은 부분 (숫자 1개)으로 나눠진 결과입니다.
4   7 | 2   5 | 3   6 | 1   8 → 숫자 1개씩을 정렬하여 병합한 결과입니다.
2   4   5   7 | 1   3   6   8 → 숫자 2개씩을 정렬하여 병합한 결과입니다.
1   2   3   4   5   6   7   8 → 마지막으로 숫자 4개씩을 정렬하여 병합한 결과입니다. 
```

병합 정렬 실행 시간의 상한은 **O(n log n)** 

숫자들을 반으로 나누는 데는 O(log n)의 시간이 들고, 각 반으로 나눈 부분들을 다시 정렬해서 병합하는 데 각각 O(n)의 시간이 걸린다.

실행 시간의 하한도 역시 **Ω(n log n)** 이다. 숫자들이 이미 정렬되었는지 여부에 관계 없이 나누고 병합하는 과정이 필요하기 때문이다.



여기서 θ 표기법이 나오는데, 이는 O과 Ω 표기가 같을 때 사용된다. 병합 정렬은 θ(n log n)이다.



